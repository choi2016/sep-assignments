1. Describe an analogy for relating an algorithm that has efficiency O(1) and another algorithm that has O(2n). An example would be:

	 O(1) is to taking a shortcut route home while O(2n) is to taking a detour

2. In plain English, what is the best case scenario for binary search?

	The best case scenario would be where the target item would be in the middle of the array since all we would need to do is compare the target item to the middle item and nothing else.

3. In plain English, what is the worst-case scenario for binary search?


	The worst case scenario would be where the target element is in the first or last position in the array. 

4. In plain English, what is the bounded-case scenario for binary search?

	The bounded case would be any iteration except for the first and last.

5.  Create a graph using the data below. Here's a CSV with the values you'll need.

	https://docs.google.com/spreadsheets/d/1cEqEp62pSdeJgTwhBxLgG2ABG4Zv7g4249T-ALfVv3s/edit?usp=sharing

6. What is the limit of the function above as n approaches infinity?

	the limit would go to positive infinity

7. What is the Big-O of an algorithm that has the data points above?

	O(2^n)

8. Write a Ruby method that takes a number n. This method must print the worst-case number of iterations for linear search to find an item in collections of size one to n. Use it to generate a table of worst-case iterations of collections up to size 10.

    def find(elements)
      if elements == 1
        p "Size: 1, Worst Case: 1 iteration"
      else
        2.upto(elements) do |n|
          p "Size: " + #{n} + ", Worst Case:" + #{n} + " iterations"
        end
      end
    end

9. Create a graph from the output using Google Sheets or other graphing software. Analyze the graph and denote its Big-O somewhere on the graph.

	Up to n = 10, the output is linear to the input. With that in mind, O(n) would be the number of elements.

10. What is the Big-O of binary search?

	O(log n).

11. What is the Big-Ω of binary search?

	O(1).

12. What is the Big-Ө of binary search?

	The bounded case must be faster than O(logn) and slower than Ω(1). We can represent the bounded case with the function 
	f(n) = (1/2) * (log n).  Since constants don't matter, 
	Ө(log n) is the bounded case.